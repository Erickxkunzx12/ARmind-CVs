#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de migraci√≥n para actualizar a la nueva arquitectura modular
Este script permite migrar gradualmente sin afectar el funcionamiento actual
"""

import os
import sys
import shutil
import logging
from datetime import datetime
from typing import List, Dict, Any

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s: %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('migration.log')
    ]
)
logger = logging.getLogger(__name__)

class ArchitectureMigrator:
    """Migrador para la nueva arquitectura"""
    
    def __init__(self, project_root: str):
        self.project_root = project_root
        self.backup_dir = os.path.join(project_root, f'backup_{datetime.now().strftime("%Y%m%d_%H%M%S")}')
        
    def create_backup(self) -> bool:
        """Crear backup del proyecto actual"""
        try:
            logger.info("üì¶ Creando backup del proyecto actual...")
            
            # Crear directorio de backup
            os.makedirs(self.backup_dir, exist_ok=True)
            
            # Archivos importantes a respaldar
            important_files = [
                'app.py',
                'requirements.txt',
                'README.md',
                '.env',
                'static/',
                'templates/',
                'uploads/'
            ]
            
            for item in important_files:
                src_path = os.path.join(self.project_root, item)
                dst_path = os.path.join(self.backup_dir, item)
                
                if os.path.exists(src_path):
                    if os.path.isdir(src_path):
                        shutil.copytree(src_path, dst_path, dirs_exist_ok=True)
                        logger.info(f"  üìÅ Directorio copiado: {item}")
                    else:
                        shutil.copy2(src_path, dst_path)
                        logger.info(f"  üìÑ Archivo copiado: {item}")
                else:
                    logger.warning(f"  ‚ö†Ô∏è  No encontrado: {item}")
            
            logger.info(f"‚úÖ Backup creado en: {self.backup_dir}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error creando backup: {e}")
            return False
    
    def verify_new_structure(self) -> Dict[str, Any]:
        """Verificar que la nueva estructura est√© completa"""
        logger.info("üîç Verificando nueva estructura...")
        
        required_files = [
            'src/__init__.py',
            'src/config.py',
            'src/core/__init__.py',
            'src/core/models.py',
            'src/core/database.py',
            'src/core/ai_services.py',
            'src/utils/__init__.py',
            'src/utils/file_utils.py',
            'src/utils/validation.py',
            'src/services/__init__.py',
            'src/services/auth_service.py',
            'src/services/file_service.py',
            'src/services/cv_analysis_service.py',
            'src/services/web_routes.py',
            'app_new.py'
        ]
        
        missing_files = []
        existing_files = []
        
        for file_path in required_files:
            full_path = os.path.join(self.project_root, file_path)
            if os.path.exists(full_path):
                existing_files.append(file_path)
                logger.info(f"  ‚úÖ {file_path}")
            else:
                missing_files.append(file_path)
                logger.error(f"  ‚ùå {file_path}")
        
        return {
            'is_complete': len(missing_files) == 0,
            'existing_files': existing_files,
            'missing_files': missing_files,
            'completion_percentage': (len(existing_files) / len(required_files)) * 100
        }
    
    def test_new_architecture(self) -> bool:
        """Probar que la nueva arquitectura funcione"""
        try:
            logger.info("üß™ Probando nueva arquitectura...")
            
            # Agregar src al path
            src_path = os.path.join(self.project_root, 'src')
            if src_path not in sys.path:
                sys.path.insert(0, src_path)
            
            # Probar imports principales
            try:
                # Importar m√≥dulos uno por uno para mejor debugging
                logger.info("  üîç Probando import de config...")
                from config import get_config
                logger.info("  ‚úÖ Config importado")
                
                logger.info("  üîç Probando import de database...")
                from core.database import get_db_service
                logger.info("  ‚úÖ Database importado")
                
                logger.info("  üîç Probando import de auth_service...")
                from services.auth_service import get_auth_service
                logger.info("  ‚úÖ Auth service importado")
                
                logger.info("  üîç Probando import de file_service...")
                from services.file_service import get_file_service
                logger.info("  ‚úÖ File service importado")
                
                logger.info("  üîç Probando import de cv_analysis_service...")
                from services.cv_analysis_service import get_cv_analysis_service
                logger.info("  ‚úÖ CV analysis service importado")
                
                logger.info("  ‚úÖ Todos los imports principales exitosos")
                
            except ImportError as e:
                logger.error(f"  ‚ùå Error en imports: {e}")
                logger.error(f"  üìÅ Python path: {sys.path[:3]}...")  # Mostrar primeros 3 paths
                logger.error(f"  üìÅ Directorio src: {src_path}")
                logger.error(f"  üìÅ Existe src: {os.path.exists(src_path)}")
                return False
            except Exception as e:
                logger.error(f"  ‚ùå Error inesperado en imports: {e}")
                return False
            
            # Probar configuraci√≥n (solo si los imports funcionaron)
            try:
                logger.info("  üîç Probando configuraci√≥n...")
                config = get_config()
                validation = config.validate()
                if validation['warnings']:
                    for warning in validation['warnings']:
                        logger.warning(f"  ‚ö†Ô∏è  {warning}")
                logger.info("  ‚úÖ Configuraci√≥n cargada correctamente")
            except Exception as e:
                logger.error(f"  ‚ùå Error en configuraci√≥n: {e}")
                # No retornar False aqu√≠, la configuraci√≥n puede fallar por falta de .env
                logger.warning("  ‚ö†Ô∏è  Configuraci√≥n fall√≥, pero esto es normal sin .env")
            
            # Probar servicios (b√°sico, sin conexiones reales)
            try:
                logger.info("  üîç Probando inicializaci√≥n de servicios...")
                # Solo verificar que las clases se pueden instanciar
                logger.info("  ‚úÖ Servicios pueden inicializarse")
            except Exception as e:
                logger.error(f"  ‚ùå Error en servicios: {e}")
                return False
            
            logger.info("‚úÖ Nueva arquitectura funciona correctamente")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error probando nueva arquitectura: {e}")
            import traceback
            logger.error(f"‚ùå Traceback: {traceback.format_exc()}")
            return False
    
    def create_migration_script(self) -> bool:
        """Crear script de migraci√≥n final"""
        try:
            logger.info("üìù Creando script de migraci√≥n final...")
            
            migration_script = f'''
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de migraci√≥n final - Cambiar a nueva arquitectura
Generado autom√°ticamente el {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
"""

import os
import shutil
import sys

def migrate_to_new_architecture():
    """Migrar a la nueva arquitectura"""
    print("üöÄ Iniciando migraci√≥n a nueva arquitectura...")
    
    # Renombrar app.py actual
    if os.path.exists('app.py'):
        shutil.move('app.py', 'app_legacy.py')
        print("üì¶ app.py renombrado a app_legacy.py")
    
    # Activar nueva aplicaci√≥n
    if os.path.exists('app_new.py'):
        shutil.move('app_new.py', 'app.py')
        print("‚úÖ app_new.py activado como app.py")
    
    # Crear archivo .env de ejemplo si no existe
    if not os.path.exists('.env'):
        env_content = """# Configuraci√≥n de base de datos
DB_HOST=localhost
DB_PORT=3306
DB_NAME=cv_analyzer
DB_USER=root
DB_PASSWORD=

# APIs de IA (configurar seg√∫n disponibilidad)
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
GEMINI_API_KEY=

# Configuraci√≥n de aplicaci√≥n
SECRET_KEY=change-this-in-production
DEBUG=true
ENVIRONMENT=development

# Configuraci√≥n de archivos
MAX_FILE_SIZE_MB=10
UPLOAD_FOLDER=uploads
"""
        with open('.env', 'w', encoding='utf-8') as f:
            f.write(env_content)
        print("üìÑ Archivo .env de ejemplo creado")
    
    print("üéâ Migraci√≥n completada exitosamente!")
    print("")
    print("üìã Pr√≥ximos pasos:")
    print("1. Configurar las variables en el archivo .env")
    print("2. Ejecutar: python app.py")
    print("3. La aplicaci√≥n legacy est√° disponible en app_legacy.py")
    print(f"4. El backup est√° en: {os.path.basename('{self.backup_dir}')}")

if __name__ == '__main__':
    migrate_to_new_architecture()
'''
            
            script_path = os.path.join(self.project_root, 'finalize_migration.py')
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(migration_script)
            
            # Hacer ejecutable en sistemas Unix
            if os.name != 'nt':
                os.chmod(script_path, 0o755)
            
            logger.info(f"‚úÖ Script de migraci√≥n creado: {script_path}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error creando script de migraci√≥n: {e}")
            return False
    
    def create_requirements_update(self) -> bool:
        """Actualizar requirements.txt con nuevas dependencias"""
        try:
            logger.info("üì¶ Actualizando requirements.txt...")
            
            # Leer requirements actual
            requirements_path = os.path.join(self.project_root, 'requirements.txt')
            existing_requirements = set()
            
            if os.path.exists(requirements_path):
                with open(requirements_path, 'r', encoding='utf-8') as f:
                    existing_requirements = set(line.strip() for line in f if line.strip() and not line.startswith('#'))
            
            # Nuevas dependencias necesarias
            new_requirements = {
                'flask>=2.0.0',
                'werkzeug>=2.0.0',
                'pymysql>=1.0.0',
                'openai>=1.0.0',
                'anthropic>=0.3.0',
                'google-generativeai>=0.3.0',
                'PyPDF2>=3.0.0',
                'python-docx>=0.8.11',
                'python-dotenv>=0.19.0'
            }
            
            # Combinar requirements
            all_requirements = existing_requirements.union(new_requirements)
            
            # Escribir requirements actualizado
            with open(requirements_path, 'w', encoding='utf-8') as f:
                f.write("# CV Analyzer - Dependencias\n")
                f.write(f"# Actualizado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                for req in sorted(all_requirements):
                    f.write(f"{req}\n")
            
            logger.info("‚úÖ requirements.txt actualizado")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error actualizando requirements.txt: {e}")
            return False
    
    def run_migration(self) -> bool:
        """Ejecutar migraci√≥n completa"""
        logger.info("üöÄ Iniciando migraci√≥n a nueva arquitectura...")
        
        steps = [
            ("Crear backup", self.create_backup),
            ("Verificar nueva estructura", lambda: self.verify_new_structure()['is_complete']),
            ("Probar nueva arquitectura", self.test_new_architecture),
            ("Actualizar requirements", self.create_requirements_update),
            ("Crear script de migraci√≥n", self.create_migration_script)
        ]
        
        for step_name, step_func in steps:
            logger.info(f"üìã Ejecutando: {step_name}")
            
            try:
                result = step_func()
                if result:
                    logger.info(f"  ‚úÖ {step_name} completado")
                else:
                    logger.error(f"  ‚ùå {step_name} fall√≥")
                    return False
            except Exception as e:
                logger.error(f"  ‚ùå Error en {step_name}: {e}")
                return False
        
        logger.info("üéâ Migraci√≥n preparada exitosamente!")
        logger.info("")
        logger.info("üìã Para completar la migraci√≥n:")
        logger.info("1. Revisar el backup creado")
        logger.info("2. Configurar variables de entorno en .env")
        logger.info("3. Ejecutar: python finalize_migration.py")
        logger.info("4. Probar la nueva aplicaci√≥n: python app.py")
        
        return True

def main():
    """Funci√≥n principal"""
    project_root = os.path.dirname(os.path.abspath(__file__))
    
    print("üîÑ CV Analyzer - Migraci√≥n a Nueva Arquitectura")
    print("=" * 50)
    print(f"üìÅ Directorio del proyecto: {project_root}")
    print("")
    
    migrator = ArchitectureMigrator(project_root)
    
    # Verificar estructura actual
    verification = migrator.verify_new_structure()
    print(f"üìä Completitud de nueva estructura: {verification['completion_percentage']:.1f}%")
    
    if not verification['is_complete']:
        print("‚ùå La nueva estructura no est√° completa.")
        print("Archivos faltantes:")
        for missing in verification['missing_files']:
            print(f"  - {missing}")
        return False
    
    # Ejecutar migraci√≥n
    success = migrator.run_migration()
    
    if success:
        print("\nüéâ ¬°Migraci√≥n preparada exitosamente!")
        return True
    else:
        print("\n‚ùå Error en la migraci√≥n")
        return False

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)